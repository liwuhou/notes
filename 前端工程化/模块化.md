### 背景

最开始的 Javascript 没有真正意义上的模块化，这跟 js 最初诞生的愿景是有关系的。最初设计的目的是通过编写一些简单的脚本来实现一些简单的浏览器交互。后面随着 js 的快速发展，前端技术得到广泛地应用，特别是 `AJAX` 与 `Jquery` 引发的前端革命，让 JS 不仅仅只是一个简单的脚本语言了，在实际的开发过程中经常会碰到诸如变量名称或函数名称冲突的问题，这不仅仅容易造成命名冲突，还会污染全局变量。随着项目越来越复杂，引用的第三方库越来越多的情况下，还可能造成文件的依赖混乱。

在这样的背景下，js 也引入了模块化的概念。最起先，js 使用 IIFE 特性实现作用域的隔断来实现模块化，后面又有了 CJS、AMD、CMD、UMD和ESM这些真正意义上的模块化。这么多的规范，经过多年的演化，目前在 web 开发 倾向于 ESM，而 Node 开发倾向于 CJS。

### 模块化的作用

模块化让 js 也能拥有自己的模块化效果，在实际开发中，一个模块就是一个文件。模块化的核心包括以下特性：

- 拆分：将代码根据功能拆分为多个可复用模块
- 加载：通过指定方式加载模块并执行与输出模块
- 注入：将一个模块的输出注入到另一个模块
- 管理：因为工程模块数量众多，需要管理模块间的依赖关系

这使得模块化以带来诸多诸如：隔离作用域、提供复用性、提高可维护性、解决命名冲突和抽离公共代码的作用。

### 模块化方案

模块化方案目前主要有六种，分别是 IIFE、CJS、AMD、CMD、UMD 和 ESM。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab60ffd815d4aaeba823661b59b42fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

目前只需关注 CJS 和 ESM，他们之间有一些细微的差别

| -        | CJS                                                  | ESM                                              |
| -------- | ---------------------------------------------------- | ------------------------------------------------ |
| 语法类型 | 动态                                                 | 静态                                             |
| 关键声明 | `require`                                            | `export` 和 `import`                             |
| 加载方式 | 运行时加载                                           | 编译时加载                                       |
| 加载行为 | 同步加载                                             | 异步加载                                         |
| 书写位置 | 任何位置                                             | 顶层位置                                         |
| 指针指向 | `this` 指向当前模块                                  | `this` 指向 `undefined`                          |
| 执行顺序 | 首次引用时**加载模块**，再次引用时**读取缓存**       | 引用时生成**只读引用**，执行时才是正式取值       |
| 属性引用 | 基本类型属于**复制不共享**，引用类型属于浅拷贝且共享 | 所有类型属于**动态只读引用**                     |
| 属性修改 | 工作空间可修改引用的值                               | 工作空间不可修改引用的值，但可通过引用的方法修改 |


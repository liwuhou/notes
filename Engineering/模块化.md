### 背景

最开始的 Javascript 没有真正意义上的模块化，这跟 js 最初诞生的愿景是有关系的。最初设计的目的是通过编写一些简单的脚本来实现一些简单的浏览器交互。后面随着 js 的快速发展，前端技术得到广泛地应用，特别是 `AJAX` 与 `Jquery` 引发的前端革命，让 JS 不仅仅只是一个简单的脚本语言了，在实际的开发过程中经常会碰到诸如变量名称或函数名称冲突的问题，这不仅仅容易造成命名冲突，还会污染全局变量。随着项目越来越复杂，引用的第三方库越来越多的情况下，还可能造成文件的依赖混乱。

在这样的背景下，js 也引入了模块化的概念。最起先，js 使用 IIFE 特性实现作用域的隔断来实现模块化，后面又有了 CJS、AMD、CMD、UMD和ESM这些真正意义上的模块化。这么多的规范，经过多年的演化，目前在 web 开发 倾向于 ESM，而 Node 开发倾向于 CJS。

### 模块化的作用

模块化让 js 也能拥有自己的模块化效果，在实际开发中，一个模块就是一个文件。模块化的核心包括以下特性：

- 拆分：将代码根据功能拆分为多个可复用模块
- 加载：通过指定方式加载模块并执行与输出模块
- 注入：将一个模块的输出注入到另一个模块
- 管理：因为工程模块数量众多，需要管理模块间的依赖关系

这使得模块化以带来诸多诸如：隔离作用域、提供复用性、提高可维护性、解决命名冲突和抽离公共代码的作用。

### 模块化方案

模块化方案目前主要有六种，分别是 IIFE、CJS、AMD、CMD、UMD 和 ESM。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab60ffd815d4aaeba823661b59b42fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

目前只需关注 CJS 和 ESM，他们之间有一些细微的差别

| -        | CJS                                                  | ESM                                              |
| -------- | ---------------------------------------------------- | ------------------------------------------------ |
| 语法类型 | 动态                                                 | 静态                                             |
| 关键声明 | `require`                                            | `export` 和 `import`                             |
| 加载方式 | 运行时加载                                           | 编译时加载                                       |
| 加载行为 | 同步加载                                             | 异步加载                                         |
| 书写位置 | 任何位置                                             | 顶层位置                                         |
| 指针指向 | `this` 指向当前模块                                  | `this` 指向 `undefined`                          |
| 执行顺序 | 首次引用时**加载模块**，再次引用时**读取缓存**       | 引用时生成**只读引用**，执行时才是正式取值       |
| 属性引用 | 基本类型属于**复制不共享**，引用类型属于浅拷贝且共享 | 所有类型属于**动态只读引用**                     |
| 属性修改 | 工作空间可修改引用的值                               | 工作空间不可修改引用的值，但可通过引用的方法修改 |

### 在 node 中使用原生 ESM

随着主流浏览器逐步支持ESM，越来越多目光投注在 node 对于 ESM 的支持上，目前 Node 使用 CJS 来作为默认的官方模块方案，虽然内置模块方案促进了 Node 的流行，但也阻碍了 ESM 的引入。

在 2017年10月31日，Node 发布了 `v8.9.0`，从此只要在命令中添加参数 `--experimental-modules`， Node 就可象征性地支持 ESM 了。

```bash
node --experimental-modules index.js
```

但在低版本的 Node 中，依然无法直接支持 ESM 解析，还需要做些手脚才行。

接着在 `v13.2.0` 带来了一些新特性，正式取消了 `--experimental-modules` 启动参数。当然并不是删除了这个参数，而是在其原有的基础上实现了对 ESM 特性的实验性支持并默认启动。

`--experimental-modules` 特性包括以下方面

- 使用 `type` 指定模块方案
  - 在 `package.json` 中指定 `type` 为 `commonjs`，则使用 CJS
  - 在 `package.json` 中指定 `type` 为 `module`，则使用 ESM
- 使用 `--input-type` 指定入口文件的模块方案，与 `type` 一样
  - 在命令中添加参数 `--innput-type=commonjs`，则使用 CJS
  - 在命令中添加参数 `--innput-type=module`，则使用 ESM
- 支持新扩展名 `.cjs`
  - 文件后缀使用 `.cjs`，则使用 CJS 解析
- 使用 `--es-module-specifier-resolution` 指定文件名称引用方式
  - 命令中添加参数 `--es-module-specifier-resolution=explicit`，则引用模块时必须使用文件扩展名（默认）
  - 命令中添加参数 `--es-module-specifier-resolution=node`，则引用模块时**无需**使用文件扩展名
- 使用 `main` 根据 `type` 指定模块方案加载文件
  - 在 `package.json` 中指定 `main` 字段，会根据 `type` 指定模块方案加载文件

### CJS 和 ESM 的判断方式
Node 要求使用 ESM 的文件采用 `.mjs` 后缀，只要文件中存在 `import/export` 命令就必须使用 `.mjs` 后缀。若不希望修改文件后缀，可在 `package.json` 中指定 `type` 为 `module`。基于此，若其它文件使用了 CJS，就需要将其文件后缀改为 `.cjs`。反之，若在 `package.json` 中指定了 `type` 为 `commonjs`，则默认的 `.js` 会被解析为 CJS，若要解析 ESM 模块的文件就需将其后缀改为 `.mjs`。

简而言之，Node 会按以下方式判断为 ESM 模块方案

- 文件后缀为 `.mjs`
- 文件后缀为 `.js` 且在 `package.json`中指定 `type` 为 `module`
- 命令中添加 `--input-type=module`
- 命令中添加 `--eval cmd`

### Node 部署 ESM 的两种方案

**原生方案**

在高版本中（也不用很高了，`v13.2.0` 以上），显式地在 `package.json` 中指定字段 `type` 为 `module` ，就开启了项目中使用 ESM 管理模块的操作。但是很快又发现问题，每次 `import` 的文件都要带上后缀，否则 node 就报错了。

```js
// import module from '../module.js';
import module from '../module';
```

node 对扩展名存在强制性是因为鼓励开发者写出 node 和 web 都通用的代码，可以在入口文件中添加 `--es-module-specifier-resolution=node` 就可以关闭这个强制后缀名的问题。

```json
{
  "scripts": {
    "start": "node --es-module-specifier-resolution=node src/index.js"
  }
}
```

在 node 中使用 ESM，除了上述问题，还存在着一些差异。特别是 ESM 不提供 node 某些特性，不能灵活引用 json 文件，还有 `__dirname`、`__filename`、`require`、`module` 和 `exports` 这些特性也无法使用了。

但是还是有一些其它的方式可以访问到

- `__filename` 与 `__dirname` 可用 `import.meta` 对象重建
- `require`、`module` 和 `exports` 就用 `import` 和 `export` 代替
- json 文件的引用可用 `fs` 模块的 `readFileSync` + `JSON.parse()` 代替

```js
import { readFileSync } from 'fs'
import { dirname } from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const json = readFileSync('./info.json')
const info = JSON.parse(json)
```

CJS 的循依赖关系通过缓存各个模块的 `module.exports` 对象解决了，但 ESM 使用了所谓的绑定，简而言之，ESM 模块不会导出导入值，而是引用值

- 导入引用模块可访问该引用但无法修改它
- 导出引用模块可为引用该模块重新分配值且该值由导入引用模块使用

而 CJS 允许在任何时间点将引用分配给模块的 `module.exports` 对象，让这些修改仅部分反映在其它模块。

**编译方案**

该方案是使用 `babel` 工具，将 `ESM` 转为 `CJS`，是低版本 node 中，比较稳地支持 `ESM` 的方案，没有之一。特别是在 node `v8.9.0` 之前的版本，无法使用 `--experimental-module` 支持 `ESM` ，也就更需使用 `babel` 来解决此类问题了。

添加相关的 babel 包

```bash
npm install -D @babel/cli @babel/core @babel/node @babel/preset-env
```

这四个 `babel` 的子包很重要，Node 能不能解析 ESM 就靠它们了

- `@babel/cli`：提供支持 `@babel/core` 的命令运行环境
- `@babel/core`： 提供转译函数
- `@babel/node`： 提供支持 ESM 的命令运行环境
- `@babel/preset-env`： 提供预设语法转换集成环境

然后在 `package.json` 中指定 `babel` 相关配置，增加一条 script 命令

```JSON
{
  "scripts": {
    "start": "babel-node src/index.js"
  },
  "babel": {
    "presets": [
      "@babel/preset-env"
    ]
  }
}
```

如果需要兼容更低的 node 版本，还可以在 `package.json` 中指定 babel 的 targets

```JSON
{
  "babel": {
    "presets": [
      ["@babel/preset-env", { "targets": { "node": "8.0.0" } }]
    ]
  }
}
```

### 总结

Node 原生部署方案适用于 高版本 Node 环境中使用，而 Node 编译部署方案，适合低版本 Node 环境或任何版本的 Node 中使用。
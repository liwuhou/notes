
![HTTP 缓存的决策指南](http://cdn.liwuhou.cn/tmp/20220316152059.png)

HTTP 缓存分为 **强缓存** 和 **协商缓存**，优先级较高的是强缓存，在命中强缓存失效的情况下，才走的协商缓存

### 强缓存的特征
强缓存是利用 http 头中的 `Expires` 和 `Cache-Control` 两个字段来控制的，强缓存中，当请求再次发出时，浏览器会根据其中的 `expires` 和 `cache-control` 判断目标资源是否命中 “强缓存”，若命中则直接从缓存中获取资源， **不会再与服务端发生通信**

命中强缓存的情况下，返回的 HTTP 状态码是 200

![](http://cdn.liwuhou.cn/tmp/20220316203703.png)

### 强缓存的实现
实现强缓存，过去一直在报文头中添加 `expires` 字段，像这样

![](http://cdn.liwuhou.cn/tmp/20220316223829.png)

给 `expires` 一个特写

```plain
expires: Web, 11 Sep 2019 16:12:18 GMT
```

可以看得出来，`expires` 是一个时间戳，后面如果浏览器再次请求该资源的时候，会对比本地时间与`expires` 时间戳，如果本地的时间小于 `expires` 设定的时间，那么就直接去缓存中获取这个资源，反之就从服务器中获取并更新资源和`expires`时间戳。
这里也能看得出问题，`expires`设定的时间来自于服务器，但是对比的本地时间却来自客户端，这样的工作机制对客户端的时间与服务器的时间之间的一致性有很高的要求。

对于这样的问题，`Cache-Control` 中的 `max-age` 字段就规避了这样的问题。`max-age`字段使用了相对的时间长度来达到相同的目的。

```plain
cache-control: max-age=31536000
```

浏览器会优先使用 `Cache-Control`中的`max-age`字段，如果应用对向下兼容有诉求，那么 `expires` 字段也可以设定同样的时间，以让那些不支持`Cache-Control`的浏览器也正常运行。

### 协商缓存：浏览器与服务器合作之下的缓存策略

协商缓存依赖于服务端与客户端之间的通信

每次浏览器使用对应资源的时候，都会向服务器发起请求去询问该缓存的相关信息，进而判断是重新发起请求、下载完整响应，还是从本地获取缓存的资源

如果服务商提示缓存资源未改动（Not Modified），资源会被**重定向**到浏览器缓存，**这种情况下网络请求对应的状态码是 304**

![](http://cdn.liwuhou.cn/tmp/20220316230508.png)


###  no-cache 与 no-store

no-cache 绕开了浏览器：我们为资源设置了 `no-cache` 之后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务器去确认该资源是否已过期（上面的协商缓存）

no-store 不需要任何缓存：当为 `no-store` 的时候，它连服务商缓存确认都不需要了，每次都是重新向服务商发送请求并下载完整的响应。

浏览器在请求发起之前都会去检查缓存，如果发现有对应的缓存资源，则去检查缓存的有效时间。

- 如果资源是在有效期内，那么则直接使用，称之为**强缓存**。在 chrome 的网络面板中看，这类请求的 `status code` 直接返回 200，`size` 返回的是 `memory cache` 或者 `disk cache`。`memory cache` 是指资源从内存中取出的，`disk cache` 则表示从磁盘中取出。当然，从内存中取出要比从磁盘中取出快很多，但资源能不能分配到内存中要取决于当下的系统状态。一般像 `base64` 这些资源是会驻留在内存中的，这几乎是浏览器的“保命”策略。通常来说，刷新页面会使用到内存缓存，关闭后重新打开会使用磁盘缓存。
- 如果资源超过有效期，则浏览器会携带该资源的缓存标识向服务端发起请求，校验是否可以继续使用，如果服务端返回了 304，并不携带任何数据，那么浏览器就可以继续使用本地的缓存；如果服务端返回了 200，并且携带更新后的资源和资源标识返回，则浏览器会使用这个新的资源，并缓存下来方便下次使用，这个称为**协商缓存**。

![HTTP 缓存的决策指南](http://cdn.liwuhou.cn/tmp/20220316152059.png)

HTTP 缓存分为 **强缓存** 和 **协商缓存**，优先级较高的是强缓存，在命中强缓存失效的情况下，才走的协商缓存

### 强缓存的特征
强缓存是利用 http 头中的 `Expires` 和 `Cache-Control` 两个字段来控制的，强缓存中，当请求再次发出时，浏览器会根据其中的 `expires` 和 `cache-control` 判断目标资源是否命中 “强缓存”，若命中则直接从缓存中获取资源， **不会再与服务端发生通信**

命中强缓存的情况下，返回的 HTTP 状态码是 200

![](http://cdn.liwuhou.cn/tmp/20220316203703.png)

### 强缓存的实现
实现强缓存，过去一直在报文头中添加 `expires` 字段，像这样

![](http://cdn.liwuhou.cn/tmp/20220316223829.png)

给 `expires` 一个特写

```plain
expires: Web, 11 Sep 2019 16:12:18 GMT
```

可以看得出来，`expires` 是一个时间戳，后面如果浏览器再次请求该资源的时候，会对比本地时间与`expires` 时间戳，如果本地的时间小于 `expires` 设定的时间，那么就直接去缓存中获取这个资源，反之就从服务器中获取并更新资源和`expires`时间戳。
这里也能看得出问题，`expires`设定的时间来自于服务器，但是对比的本地时间却来自客户端，这样的工作机制对客户端的时间与服务器的时间之间的一致性有很高的要求。

对于这样的问题，`Cache-Control` 中的 `max-age` 字段就规避了这样的问题。`max-age`字段使用了相对的时间长度来达到相同的目的。

```plain
cache-control: max-age=31536000
```

浏览器会优先使用 `Cache-Control`中的`max-age`字段，如果应用对向下兼容有诉求，那么 `expires` 字段也可以设定同样的时间，以让那些不支持`Cache-Control`的浏览器也正常运行。

### 协商缓存：浏览器与服务器合作之下的缓存策略

协商缓存依赖于服务端与客户端之间的通信

每次浏览器使用对应资源的时候，都会向服务器发起请求去询问该缓存的相关信息，进而判断是重新发起请求、下载完整响应，还是从本地获取缓存的资源

如果服务商提示缓存资源未改动（Not Modified），资源会被**重定向**到浏览器缓存，**这种情况下网络请求对应的状态码是 304**

![](http://cdn.liwuhou.cn/tmp/20220316230508.png)


###  no-cache 与 no-store

no-cache 绕开了浏览器：我们为资源设置了 `no-cache` 之后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务器去确认该资源是否已过期（上面的协商缓存）

no-store 不需要任何缓存：当为 `no-store` 的时候，它连服务商缓存确认都不需要了，每次都是重新向服务商发送请求并下载完整的响应。

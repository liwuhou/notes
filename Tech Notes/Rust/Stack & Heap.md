许多的编程语言都不太需要开发者去思考一个数据是存储在栈内存中还是堆内存中，譬如 Javascript，因为它有一套垃圾回收机制，可以释放掉运行时不被程序使用的变量的内存空间。像 c++， 则是需要程序员手动地为变量开辟或释放内存空间，所以需要经常关注数据类型的存储方式。但像 Rust，使用的[[Ownership|所有权]]来管理变量，而有意思的是这个所有权的检查发生在编程器编程源代码的时候。也就是说，Rust 的代码在编译期就要确定变量的类型以及其在内存中的存储方式。但作为一个应用程序，并不能在程序运行前就知道所以变量在内存中的存储方式，一些自己定义的变量还好，一些需要通过运行时外部用户的输入，或是读取的文件，又要怎么规定接收他们的变量在内存中的存储方式呢。这就要引出 `Stack` 内存与 `Heap` 内存在程序运行时，对变量的两种管理方式了。

### Stack 栈内存

这里的栈，与数据结构的栈还是有点区别的，但有一点相似的是：**所存储的数据大小都是固定的**。内存中的**栈内存是一块连续地从高位向低位扩展的内存空间**。换句话说，栈顶的地址和栈的最大容量是系统预先就已经规定好的了。

主要的作用是用来存储临时变量、控制信息或是函数调用。一些固定长度的数据类型，如整型、布尔型等可以直接存放在栈内存里，读写十分方便快捷。这个在 Rust 中也是一样的，Rust 在编译时就会检查数据是否能正常存放，如果有一些编译时不清楚数据类型或者是大小的数据，企图存入栈内存中就会被啪啪报错。而栈中的内存，由于其大小是固定的，值是直接存于栈中的，则其具有 [[Ownership#Copy 特性|Copy 特性]]。即直接复制值，而不是像堆中的数据一样，发生所有权的转移。

### Heap 堆内存

堆内存也跟数据结构中的堆有些区别。堆内存是一块无组织的，松散的内存空间。当你往堆中存入一个数据的时候，程序会返回其在堆中的地址，这个地址数据就是指针。堆的空间很大，但是结构松散，是一大坨向高位地址扩展的内存空间。其大小主要受限于运行环境中有效的虚拟内存，具有空间大，又比较灵活的特性。

### Rust 中的内存操作

当你声明某个变量的时候，Rust 会在内部为这个类型的数据开辟一个内存空间。如果是诸如 `i32` 或是 `bool` 等这类有固定长度的数据类型，Rust 会直接将其值存放在栈内存中。而如果是 `String` 或是 `Struct` 等这类不固定长度的复杂数据类型则会在堆中开启一个空间，将指向堆中的地址存放在栈中。

然后在 Rust 中，出现将一个变量绑定到另一个变量的时候，如果变量的值存放在栈中，Rust 会直接将栈中的值再复制一遍给新的变量。所以这里并不会发生[[Ownership|所有权的]]的转移，而是发生的数据的 [[Ownership#Copy 特性|Copy]]。而除此之外，非 `Copy` 特性的值，也就是没有固定长度的变量的情况，就会发生所有权的转移。在 Rust 中，栈中的数据，只能被一个变量所绑定，前面说的存放在栈中的数据类型，会被拷贝一份绑定给新的变量。但如果是非定长的数据类型，栈中存放的其实是指向堆内存的地址，这时就会发生所有权的转移，原生跟这个栈内存绑定的变量就被转移了所有权，后续再对其调用就会触发“所有权已被移动”的错误。而新的变量取得了其所有权。

程序开发中，经常会碰到代码报错的情况，这个其实就是程序执行时碰到不符合预期的情况，不知道要咋处理了，就报个错吧这样。特别是在 Rust 中，真的是稍不注意就编译报错，毕竟是门内存安全语言，严谨是出了名的。这个也从侧面说明，把错误提前暴露出来给开发者的重要性。

### panic!

`panic!` 是 Rust 中内置的抛错宏方法，类比 js 就是 `throw` 方法。当一些操作出现了错误，并且严重到影响整个程序的进程了，那就触发 `panic`。其中，触发 `panic` 有两种方法： 被动触发和主动调用。

### 被动触发

很好理解，凡是不是我们开发者主动调用的报错，就是被动触发的 panic。然后也很好理解，一些代码上的错误会在我们开发、程序运行的时候向我们报错，警示我们代码中存在的严重错误，这些都是好的，因为凡是在代码上线之前就发生的错误就是好错误。它让我们的代码更健壮、更安全也更合理。

经典的数组访问越界，是很严重的内存安全问题，在程序编译的时候就会报错。

```Rust
fn main() {
  let v = vec![1];
  println!("{}", v[100]);
}
```

上述代码不用编译就会在 IDE 上波浪线提示了，这种硬编译在代码中的错误一般逃不过编译时就会发生。而有一些像是接收用户输入或者接口返回的，就要等到运行时了，但 Rust 也提供了很多诸如 `get` 这样的方法，让我们来做一些逻辑的兜底。

### 主动调用

与被动触发相对的就是开发者主动调用了。Rust 提供了一个宏方法来让开发者主动抛出一个异常，这个宏就是 `panic!`。

> 如果在 main 方法里调用了 `panic!`，那么整个程序都会因为异常而中断，而如果是在某个子线程里调用 `panic!`，则当前的线程会因异常返回中断。
> 上面的现象说明了两点，一个是只有在遇到了不可恢复的错误或者是实在不知道要如何处理的时候才调用 `panic!`，因为一调用整个线程或是程序就玩完了。一个是开发的时候，尽量不要让 main 线程做太多的任务，最佳的实践就是拆分出来，交由子线程去做，这样就算是子纯种 `panic` 了，也不至于影响整个程序。

### backtrace 栈展开

在 `rustc` 报错的信息中，都有一个 note 提示可以使用栈展开的形式 debug: `` note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace ``

依运行 debug 代码的平台不同，提示的信息也不同。

- Linux/macOS 等 UNIX 系统： `RUST_BACKTRACE=1 cargo run`
- Windows 系统（PowerShell）： `$env:RUST_BACKTRACE=1 ; cargo run`

如果在 `cargo run` 指令前加入栈展开指令，就会得到更详细的 `panic` 信息，编译器会在程序遇到 `panic` 的时候，对调用栈进行回溯，会逆序地打印 `panic` 时刻所有的调用栈信息，让我们更好的排查问题。

### panic 时的两种终止方式

在项目的 `cargo.toml` 配置中，可以通过配置 `[profile.release]` 下的 `panic` 字段来管理 `panic` 的行为。`panic` 字段取值只有两种，`abort` 和 `unwinding`。

```toml
[profile.release]
panic = 'abort'
```

- `unwinding` 为默认值，表示程序发生 `panic` 了，就会以 `栈展开` 的信息来终止流程。
- `abort` 则是直接终止，不清理数据就直接退出程序，善后工作交给操作系统去负责。

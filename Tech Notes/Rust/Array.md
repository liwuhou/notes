数组的概念相信不必多说，这应该是编程里面使用最广的数据结构之一了。但在 Rust 中 ，常用的数组有两种，第一种就是速度很快但是长度固定的数据 `array`，第二种就是长度支持动态增长但是稍微有些性能损耗的 [[Vector]]。

然后在 Rust 中，`array` 与 `Vector` 的关系跟 `&str` 与 `String` 的关系很像。前者是长度固定的字符串切片，后者是可动态增长的客串。在 Rust 中， 不管是 `String` 还是 `Verctor`，它们都是高级类型：[[Collections|集合类型]]。现在我们重点放在数组 `array` 上，Rust 中的数组定义非常的简单：将多个类型相同的元素依次组合在一起，就是数组。

所以，数组的三个要素就是：

- 长度固定
- 元素有序
- 元素的类型必须相同

### 创建数组

```Rust
// 直接字面量创建
let arr1 = [1, 2, 3, 4, 5];

// 加上类型
let arr2: [i32; 5] = [1, 2, 3, 4, 5];

let arr3: [i32; 5] = [5; 5]; // 声明一个长度为 5 的，初始值为 5 的数组
```

是的，数组类型的声明语法是 `[类型; 长度];`，甚至连值的赋值语法都是这样。但事有意外，如果数组的元素乃具有 [[Ownership#Copy 特性|Copy 特性]] 类型那是没有什么问题，可如果是非基本类型就会出问题了。

```Rust
let string_array = [String::from("rust"); 5];
```

这么写会报错，因为在 Rust 底层，会不断地调用传入元素的 Copy 特性的值，直到填满整个数组长度。而复杂类型根本没有深拷贝特性，只能一个一个地创建。这个时候我们就可以调用 `std::array::from_fn` 了。

```Rust
let array: [String; 8] = std::array::from_fn(|_i| String::from("rust"));
```

### 数组切片

同 `String` 的切片，数组也支持切片，允许我们引用集合中的部分连续片段，而不是整个集合。

```Rust
let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice: &[i32] = &a[1..3];

assert_eq!(slice, &[2, 3])
```

由上述代码可知，数组切片的类型不是 `[i32; 5]`，而是 `&[i32]`。数组切片具有如下特点：

- 切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置
- 创建切片的代价非常的小，因为切片只是针对底层数组的一个引用
- 切片类型 `[T]` 拥有不固定的大小，而切片引用类型 `&[T]` 则具有固定的大小。

特别是最后一条特点，因为在 Rust 中，很多时候都需要固定大小的数据类型，因此 `&[T]` 更有用，`&str` 也同理。

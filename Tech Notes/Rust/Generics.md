多态在程序中非常重要，不供能为程序员提供编程上的便利，也能丰富语言本身的表达能力。一个函数，可以拥有多种状态的输入输出，能代替很多个其它的函数，实在是一件很省事的特性。而泛型（`Generics`）就是一种多态，能让某个函数具有多种多样的函数签名。在 Go、Typescript 等编程语言中，泛型已经大放异彩，它是一种能让强类型语言也具有很强灵活性的东西。

```Rust
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
  a + b
}

let a: i8 = add(2i8, 3i8); //
```

上述的代码中，`T` 就是泛型参数，跟其它支持泛型特性的编程语言一样，Rust 中的泛型参数也是可以随便起的。但是出于习惯，一般都是叫 `T` 、`U` 这些，基本上参数名字是越短越好，除非是有表达具体含义的需要。

使用泛型参数前，要先对其进行声明，这点也跟 Typescript 一样：

```Rust
fn max<T>(list: &[T]) -> T {
  todo!();
}
```

在方法名后面的 `<T>` 就是声明的泛型参数。如果只是这样，那么 `T` 就可以是类型，但在实际的开始中，这样的场景基本上是不可能的。所以常需要配合 [[Trait]] 来约束泛型参数的类型范围了。

### 约束泛型的类型范围

比如有这么一个函数，接收 `i8`或者 `u8` 等 `int` 类型的参数作相加，然后返回他俩的和（跟传入的类型相同）。如果按上面所学的泛型的知识，很容易就能写出这样的函数。

```Rust
fn add<T>(a: T, b: T) -> T {
  a + b
}
```

但如果我们使用 `rustc` 编译一下，马上就能被编译器无情的打脸——编译器返回了一个 `error[E0369]: cannot add T to T` 的错误。原因是并不是所有的 T 类型都能进行相加的操作，因此要使用一个可以相加的特征来限制泛型类型。具有可以执行相加操作的特征就是 `std::ops::Add`，所以要把代码改为：

```Rust
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
  a + b
}
```

这样就正常了，后面会深入展开 `Trait`，先对些有个大致的印象就行。

### const 泛型

这是在 Rust 1.51 版本引入的重要特征，主要是用来实现针对**值**的泛型

多态在程序中非常重要，不供能为程序员提供编程上的便利，也能丰富语言本身的表达能力。一个函数，可以拥有多种状态的输入输出，能代替很多个其它的函数，实在是一件很省事的特性。而泛型（`Generics`）就是一种多态，能让某个函数具有多种多样的函数签名。在 Go、Typescript 等编程语言中，泛型已经大放异彩，它是一种能让强类型语言也具有很强灵活性的东西。

```Rust
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
  a + b
}

let a: i8 = add(2i8, 3i8); //
```

上述的代码中，`T` 就是泛型参数，跟其它支持泛型特性的编程语言一样，Rust 中的泛型参数也是可以随便起的。但是出于习惯，一般都是叫 `T` 、`U` 这些，基本上参数名字是越短越好，除非是有表达具体含义的需要。

使用泛型参数前，要先对其进行声明，这点也跟 Typescript 一样：

```Rust
fn max<T>(list: &[T]) -> T {
  todo!();
}
```

在方法名后面的 `<T>` 就是声明的泛型参数。如果只是这样，那么 `T` 就可以是类型，但在实际的开始中，这样的场景基本上是不可能的。所以常需要配合 [[Trait]] 来约束泛型参数的类型范围了。

### 约束泛型的类型范围

比如有这么一个函数，接收 `i8`或者 `u8` 等 `int` 类型的参数作相加，然后返回他俩的和（跟传入的类型相同）。如果按上面所学的泛型的知识，很容易就能写出这样的函数。

```Rust
fn add<T>(a: T, b: T) -> T {
  a + b
}
```

但如果我们使用 `rustc` 编译一下，马上就能被编译器无情的打脸——编译器返回了一个 `error[E0369]: cannot add T to T` 的错误。原因是并不是所有的 T 类型都能进行相加的操作，因此要使用一个可以相加的特征来限制泛型类型。具有可以执行相加操作的特征就是 `std::ops::Add`，所以要把代码改为：

```Rust
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
  a + b
}
```

这样就正常了，后面会深入展开 `Trait`，先对些有个大致的印象就行。

### const 泛型

这是在 **Rust 1.51 版本引入的重要特征**，主要是用来实现针对**值**的泛型。
在[[Array]]中我们说过，数组的类型语法为 `[类型;长度]`，对于 Rust 来说，这要数组的长度不同，那么就会认为是两个不同的数组。看下下面的例子：

```Rust
fn display_array(arr: [i32; 3]) {
  println!("{:?}", arr);
}
fn main() {
  let arr1: [i32; 3] = [1, 2, 3];
  let arr2: [i32; 2] = [1, 2];
  display_array(arr1);
  display_array(arr2); // 报错
}
```

可以看到在调用 `display_array(arr2)` 的时候，程序报错了，因为传入函数的数组与规定的类型不符。那有朋友就要说了，我改 `display_array` 函数中参数的定义不就行了，把 `3` 改成“任意数”，如果有这种操作的话。这个操作在 Rust 1.51 引入 `const` 泛型之后才可以实现。在这个 `const` 泛型引入之前，要么传入数组的引用形式：

```Rust
fn display_array<T: std::fmt::Debug>(arr: &[T]) {
  println!("{:?}", arr);
}
```

要么就使用“码海战术”，疯狂地为所以数组的长度写方法（所以以前 Rust 的一些数组库，在使用的时候都限定长度不超过 32，你知道原因了吧，因为他们都单独地为每一个长度实现一个函数）。毕竟在某些场景下可能还不能使用引入呢。

```Rust
// 大概代码长这样
fn display_array_2(arr: [i32; 2]) {}
fn display_array_3(arr: [i32; 3]) {}
fn display_array_4(arr: [i32; 4]) {}
// 还有二十多个函数要写，宝宝心里贵...
```

而引入了 `const` 泛型后呢，使用就优雅很多了。

```Rust
fn display_array<T: std::fmt::Debug, const N: usize>(arr: [T, N]) {
  println!("{:?}", arr); // 这下啥长度的数组都能打了
  println!("{}", N); // 而且这个 N 还是能直接在函数体中用的
}
```

`N` 就是 `const` 泛型，通过 `const N: usize` 来定义，表示 `N` 基于 `usize` 类型，更重要的是，`N` 是一个基于值的泛型参数。在泛型参数之前，Rust 完全不适合复杂矩阵的运算，有了 `const` 泛型，做这些就简单多了。

### 泛型的性能

在 Rust 中泛型是零成本的抽象，因为你在使用泛型的时候，Rust 会为每个泛型代码进行 **单态化(Monomorphization)`** 处理，来保证代码效率。简而言之就是，单态化处理会将所有泛型代码都生成处理具体类型的代码。举个例子：

```Rust
let i = Some(5);
let f = Some(5.0);
```

我们使用 `Option` 枚举，传入了 `i32` 与 `f64` 两种类型，编译器读取传递给 `Option<T>` 的值改善有两种 `Option<T>` 类型，它就会将泛型定义 `Option<T>` 展开为 `Option_i32` 与 `Option_f64`，然后将泛型定义替换为具体的两个定义。编译器生成之后的代码看起来像这样：

```Rust
enum Option_i32 { // 生成具体类型对应的定义
  Some(i32),
  None,
}
enum Option_f64 {
  Some(f64),
  None,
}

fn main() {
  let i = Some_i32(5); // 这里则去调用具体类型的方法
  let f = Some_f64(5.0);
}
```

这样处理也会让 Rust 在运行“泛型”代码的时候没有任何的运行时开销，它执行代码的效率就好像手写每个具体定义的重复代码一样（事实上编译器帮我们重写了），这个单态化的过程，正是 Rust 泛型在运行时效率极高的原因。但这也牺牲了编译的速度还有最终生成文件的大小。

纵观所有编程语言所编写的应用程序，都必须要与计算机内在打交道，软件在运行时会不断地向内存索取空间来存放程序运行的内容，也会不断地在程序不需要的时候释放内存空间防止内在溢出。如何权衡和取舍，这也成了计算机编程的艺术。而在计算机语言不断地演变中，出现了三种流派：

- 垃圾回收机制（GC），在程序运行时不断地寻找程序不同使用的内存，典型代表有：JS、Java 和 go
- 手动管理内存的分配和释放，在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- 通过所有权来管理内存，编译器在编译时会根据一系列的规则进行检查，Rust 就是这一类

Rust 选择了通过所有权的形式来管理程序运行中的内存，然后有意思的是，这种所有权的检查只发生在编译期，因此在程序运行期，不会有任何性能上的损失。

### 所有权原则

> 1. 在 Rust 中，每一个值都有一个所有者
> 2. 在同一时刻，每一个值只有一个所有者
> 3. 当所有者离开上下文之后，值将被丢弃，这部分的内存将被回收

所有者可以等价于变量。

要理解所有权概念，还要先清楚堆栈的概念。在 Rust 中，简单的基本数据类型（大小已知且不变）会直接保存在栈中，而大小未知或者可能变化的数据就需要存储在堆上。依运行程序的设备的性能不同，栈和堆的读写速率也不一样，但基本上，栈往往是存储在 cpu 的高速缓存中，而堆数据只能存储在内存里，而高速缓存与内存的访问速度差异基本是在 10 倍以上的。访问堆里的数据天然地要比访问栈上的慢，更何况访问堆前还必须通过访问栈，再通过栈上的指向堆的指针去访问内存。

#### 基本类型数据的所有权变化

```rust
let x = 1;
let y = x;

let b = true;
let b2 = b;
```

这样的赋值操作并不会发生所有权转移。原因是一个整数大小（i32， 4 个字节）的数据比较简单，直接拷贝的速度要比在堆上创建内存要快很多。因此这类基本数据的赋值只会发生数据的拷贝，并不要发生所有权转移。

#### 复杂类型数据的所有权变化

```rust
let s1 = String::from("Hello world");
let s2 = s1;

// 如果作用域内后续代码依然引用了 s1，就会被编译啪啪报错
println!("{}", s1);
```

上面的代码就会让编译器报错了，原因是 String 类型是一个复杂类型，如果直接拷贝 s1 在内存中的数据会对性能造成极大的开销。
那既然拷贝堆上的数据开销很大，那我们如果只复制变量在栈上的数据会怎样。这样当然性能上不会有太大的问题，毕竟在栈上存储的只是指向堆的地址。但在变量离开作用域之后，Rust 会自动调用 drop 函数并清理变量的堆内存时，这里会有两个变量指向相同的堆地址，这就释放了两次相同的内存。这是一个叫二次释放（double free）的错误，也是内存安全性的 bug 之一。所以 Ownership rules 说，在同一时刻，值只有一个所有者。这类错误在 Rust 的编译阶段就会抛出，提醒开发者修改。

![Transfer Ownership](http://cdn.liwuhou.cn/tmp/20230626074941.png)

在其它编程语言中，可能上述的代码称之为浅拷贝，而在 Rust 中的复杂类型中，赋值更不像赋值，他更像是绑定，而这类浅拷贝的操作更是被称为“移动（move）”。所以上面的例子就是，s1 被移动到了 s2。解释下就是 s1 不再指向任何数据了，只有 s2 是有效的，当 s2 离开作用域时，它就会被释放内存。

而克隆（深拷贝）呢，_在 Rust 中，**复杂数据**永远也不会自动创建数据的“深拷贝”_，因此，任何自动复制的操作都不是克隆。依然以上面的例子来说明，如果我们真的希望深拷贝 String 变量在堆上的数据，就要显性地调用各类深拷贝的方法，在 String 类型中有一个 `clone` 方法。

```rust
let s1 = String::from("hello world");
let s2 = s1.clone();

println!("{}, {}", s1, s2); // 不会报错了，因为这次 s1 并没有发生转移
```

### Copy 特性

Rust 中有一个叫作 `Copy` 的特征，指的是类似整型这样在栈中存储的类型，所具有的旧的变量被赋值给其它变量后依然可以使用的特性。

具体什么类型具有 `Copy` 特征呢？可以查看给定类型的文档来确认，不过作为一个通用的规则是：任何基本类型及其组合都可以 `Copy`，不需要分配内在或某种形式资源的类型也是可以 `Copy`的。如下是一些具有 `Copy` 的类型：

- 所有整数类型，比如 `u32`，`i32`
- 布尔类型，`bool`
- 所有浮点类型，比如 `f64`
- 字符类型，`char`
- 具有`Copy`特性构成的元组，比如 `(i32, u32)` 是`Copy`，但 `(i32, String)` 就不是了
- 不可变引用 `&T`，比如 `&str`

所以下面的 Rust 代码是可以正常跑的

```rust
fn main() {
  let x: &str = "hello";
  let y = x;
  println!("{}, {}", x, y);
}
```

### 函数传值与返回

将值传给函数，一样会发生 `移动` 或 `Copy`，表现跟 `let` 语句相似。

```rust
fn main() {
  let s = String::from("test");

  takes_ownership(s);
  println!("{}", s); // 报错了，提示 s 被移动

  let x = 5;

  makes_copy(x);
  println!("{}", s); // 这里正常执行
}

fn takes_ownership(str: String) {
  println!("{}", str);
}

fn makes_copy(x: i32) {
  println!("{}", x);
}
```

函数的返回也同理，受 Ownership Rules 约束。

```rust
fn main() {
  let s1 = gives_ownership();         // gives_ownership 将返回值
                                      // 移给 s1
  let s2 = String::from("hello");     // s2 进入作用域
  let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                      // takes_and_gives_back 中,
                                      // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
                                            // 调用它的函数

  let some_string = String::from("hello"); // some_string 进入作用域.

  some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
  a_string  // 返回 a_string 并移出给调用的函数
}

```

上面的例子看下来，会觉得写 rust 代码很费劲，函数难道就不能像其它编程语言一样，使用的是传入来的引用，然后使调用前的上下文里不发生变量转移吗？
当然是可以的，这就是涉及到[[References & Borrowing|引用与借用]]的特性了。

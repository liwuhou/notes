语句（Statements）与表达式（Expressions）是组成一个程序的重要部分，语句会会执行一些操作，一般不会返回一个值，而表达式会在求值后返回一个值。

```Rust
fn addTen(x: i32) -> i32 {
  let ten = 10; // 语句
  x + ten // 表达式
}

let twenty = addTen(10);
println!("{}", twenty); // 20
```

### Statements

前面说过，语句不返回值，只是完成一个具体的操作。因此下列的代码是错误的

```Rust
let a = (let b = 10); // 啪啪报错
```

rust 的编译器会告诉我们，上述的 `let` 是一个语句，不是一个表达式，因此没有返回值，也就不能赋值给其它的变量。

> 但是，`let` 作为表达式已经是 Rust 目前的试验功能了，可能在不久的将来，在正式版的 Rust 中就能这样使用了。

### Expressions

表达式会进行求值，然后返回一个值。例如 `1 + 1`，在求值后会返回 `2`，因此它就是一个表达式。
另外，一个单的值就是一个表达式，如 `let num: i32 = 1` 中的 `1` 就是一个表达式，它会返回 `i32` 类型的 `1`。
用花括号包裹起来的块代码，只要最终返回了一个值，那么他也是一个表达式。

```Rust
fn main() {
  let y = {
    let x = 3;
    x
  }
  println!("{}", y); // 3
}
```

值得注意的是，在函数或花括号中，最后面的表达式会被当作值返回，上面 `let y = {}` 的花括号中的 `x` 就是一个表达式，需要注意的地方是不能为它添加分号结尾，因为这样就会把他从表达式变成语句。而如果一个函数没有返回任何值，那 Rust 也会让它隐式地返回一个[[Char & Bool & Unit type#单元类型（unit type)|单元类型]]值 `()`。

```Rust
fn return_unit_type() {
  let x = 1;
  x; // 函数尾部加了分号就变为语句了，所以返回了 ()
}
assert_eq!(return_unit_type(), ());
```

函数与块级作用域都会将最末尾的表达式当作值返回出去，所以 Rust 中的 `if` 可以实现类似三元运算符的用法：

```Rust
let x = 1;
let y = if x % 2 == 1 {
  "odd"
} else {
  "even"
}

// 或者直观的写作一行
let z = if x % 2 == 1 { "odd" } else { "even" };
```

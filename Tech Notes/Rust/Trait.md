Rust 中的特征，在其它编程语言中有着另外的一个名字 —— 接口（interface）。在 Rust 中，特征定义了一组可以被共享的行为，只要实现了特征，你就能使用这个行为。像在 [[Generics]] 中提到的，定义了一个泛型参数 `T`，只有 `T` 实现了 `std::ops::Add` 才可以进行合法的加法操作。

```Rust
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
  a + b
}
```

这其实也点明了特征的作用 —— 特征定义了一组可以被共享的行为，只要实体实现了特征，就能使用特征定义的行为。

### 定义特征

如果有不同的类型具有相同的行为，例如上面的 `i32` 类型和 `f64` 类型都具有加法的行为。那么就可以定义一个特征，为这些类型实现该特征。
举个更具体的例子，我养了一只猫猫和一条修勾，他们都具有相同的行为：吃饭、睡觉、拆家。对于铲屎官来说，这二货的行为基本都是相似的，可以共享的。因此是可以抽象为这么一个特征：

```Rust
pub trait Pet {
  fn eat(&self) -> String;
  fn sleep(&self) -> String;
  fn break_down_your_furniture(&self, furniture: &str) -> String;
}
```

这里声明特征需要用来关键字 `trait`，上面代码中 `Pet` 即是特征名。而在大括号中定义的都是该特征具有的方法（行为）。
特征不用管方法的具体实现，只需要给出方法的签名，正如猫猫和狗狗都会拆家，但他们的具体行为与破坏力又都有一些不同一样。

### 为类型实现特征

以性能优化的角度看这个问题，总共分为五步：

1. DNS 解析
2. 建立TCP 连接
3. HTTP 请求抛出
4. 服务端处理请求，HTTP 响应返回
5. 水产品拿到响应数据，解析响应内容，把解析的结果展示给用户

### 网络层面上的优化
DNS 解析时长长，可以尽量减少次数或者将解析前置，浏览器 DNS 缓存和 DNS prefetch。
TCP 每次建立都要历经三次握手，可以使用 「长连接」、「预连接」和接入 「SPDY 协议」
前端的能做的在减少 http 请求，和请求体积。部署时，将资源部署在离用户更近的 cdn 服务器上

### 浏览器层面上的性能优化

涉及资源加载优化、服务器渲染、浏览器缓存机制的利用、DOM 树的构建、网页排版和渲染过程、回流和重绘的考量、DOM 操作的合理规避等等，这也正是前端工程师在性能优化上的主要战场

![](http://cdn.liwuhou.cn/tmp/20220303164535.png)

很典型的八股文了，整理一遍流程。

浏览器有三个进程：浏览器进程、网络进程和渲染进程。

1. 浏览器进程负责处理、响应用户的交互，比如点击、滚动
2. 网络进程负责处理数据的请求、提供下载功能
3. 渲染进程负责将获取到的 HTML、CSS、JS 处理成可以看见和交互的页面


而「从 URL 输入到页面渲染」整个过程可以分成网络请求和浏览器渲染两个部分，分别由网络进程和渲染进程去处理。
接下来了是围绕着这三个进程展开。

## 网络请求
1. URL 的解析
2. 检查资源缓存
3. DNS 解析
4. 建立 TCP 连接
5. TLS 协商密钥
6. 发送请求和接收响应
7. 请求结束，关闭 TCP 连接

### URL 解析
首先浏览器会判断输入的是一个 URL 还是搜索的关键字。

完整的 URL 应该是 `协议+主机+端口+路径[+参数][+锚点]`。

如果输入的是个 URL，浏览器会尝试着将用户输入的 URL 拼接成完整的 URL，比如在地址栏输入：`baidu.com`，浏览器最终会将其拼接成 `https://www.baidu.com`，`https` 协议默认使用 443 端口，`http` 默认使用 80。

如果是搜索的关键字，会将其拼接到浏览器中默认的搜索引擎的参数部分去访问。这个流程需要对输入的不安全字符编码进行转义（安全字符是指数字、英文和少数的符号）。因为 URL 的参数是不能有中文的，也不能有一些特殊字符，比如 `= ？ &`，否则就会产生歧义。

URL 对非安全字符转义时，使用的编码叫百分号编码，因为它使用百分号加上两位的 16 进程数表示。这两位 16 进制数来自 UTF-8 编码，将每一个中文都转成 3 个字节。我们在开发的时候经常使用到的 `encodeURI` 和 `encodeURIComponent` 正是起的这个作用，它们的规则基本一样，只是 `= ? & ; /` 这类 URL 组成的符号在 `encodeURI` 中不会被编码，但是在 `encodeURIComponent` 中会被编码。因为 `encodeURI` 是编码整个 URL，而 `encodeURIComponent` 编码的是参数部分，需要更加严格把关。

### 检查缓存
检查缓存一定是发生在请求之前进行的，不然缓存机制就没有意义了。如果在请求前发现了有对应的缓存资源，则会去检查缓存的有效期。

有关浏览器的缓存可见[[HTTP 缓存机制]]

### DNS 解析
如果没有成功使用本地缓存，就需要发起网络请求了，而发起请求首先要做的就是 [[计算机网络原理#域名解析的过程⭐|DNS 的解析]]

DNS 解析会依次搜索：

1. 浏览器的 DNS 缓存
2. 操作系统的 DNS 缓存
3. 路由器的 DNS 缓存
4. 向服务商 DNS 服务器查询
5. 向全球 13 台根域名服务器查询

为了节省时间，可以在 HTML 头部去做 DNS 的预解析

```html
<link rel="dns-prefetch" href="http://www.baidu.com" />
```

>  为了保证响应的及时，DNS 解析使用的是 UDP 协议。

### 建立 TCP 连接
http 请求都是基于 TCP 协议的，服务器与客户端通信之前要建立可靠的 TCP 连接，建立的过程就涉及到常说的[[计算机网络原理#TCP 连接的建立和拆除|三次握手]]

> 三次握手是为了保证客户端存活,防止服务端在收到失效的超时请求造成资源浪费。

### 协商加密密钥 —— TLS 握手
为了保障通信的安全，一般都采用https协议，基本的 S 指的就是 TLS。TLS 使用的是一种「非对称+对称的方式进行加密。采取这二者结合的方式是为了让加密解密的过程更安全性能也更好。

对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。这种加密方式速度很快，但是问题在于如何让双方知道秘钥。因为 传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，秘钥被截获，就失去了加密的意义。

非对称加密，每个人都有一把公钥和私钥，公钥所有人都可以知道，私钥只有自己知道，将数据用公钥加密，解密必须使用私钥。这种加密方式就可以完美解决对称加密存在的问题，缺点是速度很慢。

而 TLS 采取非对称加密的方式协商出一个对称密钥，这个密钥只有发送方和接收方知道的密钥，流程如下：

1. 客户端发送一个随机值以及需要的协议和加密方式
2. 服务端收到客户端的随机值，发送自己的数字证书，附加上自己产生的一个随机值，并根据客户端需求的协议和加密方式使用对应的方式
3. 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端
4. 服务端收到加密过的随机值并使用私钥解密获得第二个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该对称密钥来加密和解密了。

![](http://cdn.liwuhou.cn/tmp/20220408065941.png)

通过以上步骤可知，在TLS握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式。

### 发送请求和接收响应
HTTP 默认的端口是 80，而 HTTPS 的默认端口号是 443

请求的基本组成是 `请求行+请求头+请求体`

```
POST /hello HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 
Host: www.example.com 
Accept-Language: en, mi 

name=niannian
```

响应的基本组成是 `响应行+响应头+响应体`

```
HTTP/1.1 200 OK
Content-Type: application/json
Server: apache

{password: '123'}
```

### 关闭 TCP 连接
当数据传输完毕之后，就要关闭 TCP 连接了，关闭连接的主动方可以是客户端，也可以是服务端，整个过程有四次的交互，又称为[[计算机网络原理#TCP 连接的拆除——四次挥手|四次挥手]]。

#### 主动方为什么会等待2MSL

客户端在发送完第四次的确认报文段后会等待2MSL才正真关闭连接，MSL是指数据包在网络中最大的生存时间。目的是确保服务端收到了这个确认报文段，

假设服务端没有收到第四次握手的报文，试想一下会发生什么？在客户端发送第四次握手的数据包后，服务端首先会等待，在1个MSL后，它发现超过了网络中数据包的最大生存时间，但是自己还没有收到数据包，于是服务端认为这个数据包已经丢失了，它决定把第三次握手的数据包重新给客户端发送一次，这个数据包最多花费一个MSL会到达客户端。

一来一去，一共是2MSL，所以客户端在发送完第四次握手数据包后，等待2MSL是一种兜底机制，**如果在2MSL内没有收到其他报文段，客户端则认为服务端已经成功接受到第四次挥手，连接正式关闭。**

## 浏览器渲染
当浏览器拿到了数据，渲染进程就开始渲染工作了。浏览器渲染会完成以下几个工作：
1. 构建 DOM 树
2. 样式计算
3. 布局定位
4. 图层分层
5. 图层绘制
6. 显示

### 构建 DOM 树
html 文件的结构没法被浏览器理解，所以先要把 HTML 中的标签变为可以给 js 使用的结构
在控制台中可以打印出 DOM，这就是被解析出来的 DOM 树

![](http://cdn.liwuhou.cn/tmp/20220330232111.png)

### 样式计算
